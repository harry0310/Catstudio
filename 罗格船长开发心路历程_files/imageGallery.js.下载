/**
 * Copyright 2012-2015 Evernote Corporation.
 */

/**
 * An image gallery that can display images, one at a time, given an
 * array of image URLs.
 */
define(
    [ "jquery", "common", "i18n", "templates", "text!ImageGalleryBase/imageGallery.html",
        "css!ImageGalleryBase/imageGallery", "domReady!" ],
       function($, common, i18n, templates, imageGalleryTemplate) {
  var DRAGGED_STYLE = "dragged";
  var GRAYED_OUT_STYLE = "grayed-out";
  var HIDDEN_STYLE = "hidden";
  var KEY_DOWN = 40;
  var KEY_ENTER = 13;
  var KEY_ESCAPE = 27;
  var KEY_H = 72;
  var KEY_J = 74;
  var KEY_K = 75;
  var KEY_L = 76;
  var KEY_LEFT = 37;
  var KEY_NUMPAD_2 = 98;
  var KEY_NUMPAD_4 = 100;
  var KEY_NUMPAD_6 = 102;
  var KEY_NUMPAD_8 = 104;
  var KEY_PAGEDOWN = 34;
  var KEY_PAGEUP = 33;
  var KEY_RIGHT = 39;
  var KEY_UP = 38;
  var LOADING_GIF = "/redesign/global/js/component/ImageGallery/img/gallery-loading.gif";
  var MODAL_STYLE = "imggal-modal";
  var NAV_FADEOUT_TIME = 1500;
  var NAV_FULL_STYLE = "nav-full";
  var NAV_HIDDEN_STYLE = "nav-hidden";
  var OFF_SCREEN_STYLE = "off-screen";
  var SWIPE_TRANSITION_TIME = 200;

  var DEFAULTS = {
    /**
     * Number of upcoming images to queue and prefetch in the DOM.
     */
    prefetchSize: 3,

    /**
     * Enable mouse and touch swiping, and its associated CSS animations.
     */
    swipe: true,

    /**
     * Image index to open at
     */
    initImage: 0
  };

  // jQuery containers
  var allNavs;
  var closeFullScreenIcon;
  var newTabIcon;
  var closeIcon;
  var downloadIcon;
  var fullScreenIcon;
  var glass;
  var imageGalleryContainer;
  var imageQueue;
  var imagesContainer;
  var navBar;
  var nextIcon;
  var notNavBar;
  var onDeckContainer;
  var prevIcon;

  var cancelFullScreenStr = null;
  var closeCallback = null;
  var closeFullScreenCallback = null;
  var currentImageIdx = 0;
  var deferredShow = null;
  var fullScreenCallback = null;
  var imageDist = $(window).width();
  var imageGalleryHtml = null;
  var imageLoadTimeoutId = null;
  var images = null;
  var imageQueueSize = 0;
  var isFullScreenStr = null;
  var lastQueuedIdx = -1;
  var mousemoveTimeoutId = null;
  var nextCallback = null;
  var onfullscreenchangeStr = null;
  var opts = null;
  var prevCallback = null;
  var preventInput;
  var requestFullScreenStr = null;
  var totalImages = 0;

  /**
   * Sets up mouse movement and click handlers to show and hide the nav
   * bar, and to activate each of its clickable options.
   */
  var addNavBarHandlers = function() {
    if (!supportsFullScreen()) {
      allNavs.addClass("nav-no-full");
    } else {
      setOnfullscreenchange(function() {
        isFullScreen() ? onFullScreen() : onCloseFullScreen();
      });
      fullScreenIcon.click(requestFullScreen);
      closeFullScreenIcon.click(cancelFullScreen);
    }
    nextIcon.click(onNext);
    prevIcon.click(onPrev);
    downloadIcon.click(function() {
      window.open(images[currentImageIdx].split("?")[0] + "?attachment", "_top");
    });
    newTabIcon.click(function() {
      window.open(images[currentImageIdx].split("?")[0], "_blank");
    });
    closeIcon.click(onClose);

    notNavBar.on("mousemove.imggal", function() {
      showNav(true);
    });
    navBar.on("mousemove.imggal", function() {
      showNav();
      return false;
    });
  };

  /**
   * Adds mouse and touch handlers for swiping the image, which visibly
   * moves it on the screen and transitions to next or previous images.
   */
  var addSwipeHandlers = function() {
    if (!opts.swipe) {
      imagesContainer.children().addClass("no-swipe");
      return;
    }

    // Cached DOM elements.
    var $window = $(window);
    var displayImages;

    // Position and time variables for swipe end calculations.
    var devicePixelRatio = !common.isIE ? window.devicePixelRatio || 1 : 1;
    var maxTarget = imageDist / 3;
    var minTarget = 10;
    var maxTime = 500;
    var minTime = 20;
    var newX;
    var startTouchTime;
    var startX;
    var touching;

    /**
     * Move each image to their pre-swipe positions, totally
     * off of the screen.
     *
     * @param {$Elements} displayImages Each display image element in
     *     their correct ordering (lowest index is furthest left, while
     *     highest index is furthest right).
     */
    var resetImagePositions = function(displayImages) {
      $.each([-imageDist, 0, imageDist], function(idx, val) {
        displayImages.eq(idx).css(transformCss(val));
      });
    };

    $window.resize(function() {
      // On resize, space images apart properly.
      imageDist = $window.width();
      var maxTarget = imageDist / 3;

      resetImagePositions(imagesContainer.children());
    });

    var getBounceCalculationFn = function() {
      var alwaysFn = function(diffX) {
        return diffX / 4;
      };
      var noPrevOnlyFn = function(diffX) {
        return diffX / (diffX > 0 ? 4 : 1);
      };
      var noNextOnlyFn = function(diffX) {
        return diffX / (diffX < 0 ? 4 : 1);
      };
      var neverFn = function(diffX) {
        return diffX;
      };

      var prev = hasPrev();
      var next = hasNext();
      return !prev && !next ? alwaysFn :
          (!prev ? noPrevOnlyFn :
              (!next ? noNextOnlyFn : neverFn));
    };
    var bounceCalculationFn;

    /**
     * Start swipe animation, getting initial screen points, applying
     * styles, and preventing nav bar input.
     */
    var swipeStart = function(e, touch) {
      if (preventInput) {
        return;
      }

      // Do not switch images until swipe end.
      preventInput = true;

      // Get initial screen point, for mouse or touch.
      var screenX =
          (touch ? e.touches[0].screenX : e.screenX) / devicePixelRatio;

      // Track position and time pressed.
      startX = newX = screenX;
      startTouchTime = new Date().getTime();
      touching = true;

      bounceCalculationFn = getBounceCalculationFn();

      // Cache images in their current order, and remove transition styles.
      displayImages = imagesContainer.children();
      displayImages.addClass(DRAGGED_STYLE);
    };

    imagesContainer.on('mousedown.imggal', function(e) {
      if (e.which === 1) {
        swipeStart(e, false);
        return false;
      }
    });
    imagesContainer.on('touchstart.imggal', function(e) {
      swipeStart(e.originalEvent, true);
      return false;
    });

    /**
     * Given multiple touch inputs, get the best screenX for the provided
     * original point. In this iteration, the best screenX is the furthest
     * screenX from the original point.
     */
    var getBestScreenX = function(touches, pointX) {
      var maxDiff = 0;
      var bestScreenX = pointX;

      // Reduce to screenX that is furthest away from pointX.
      $.each(touches, function() {
        var thisScreenX = this.screenX;
        var thisDiff = Math.abs(thisScreenX - pointX);

        if (thisDiff > maxDiff) {
          // This point is further; update it.
          maxDiff = thisDiff;
          bestScreenX = thisScreenX;
        }
      });

      return bestScreenX;
    };

    /**
     * Animate the images to follow the movement of the mouse or touch
     * in the horizontal axis.
     */
    var swiping = function(e, touch) {
      if (!touching) {
        return;
      }

      // Find current position of mouse or touch.
      newX = (touch ? getBestScreenX(e.changedTouches, startX) : e.screenX) /
          devicePixelRatio;

      var diffX = newX - startX;

      // If the user is scrolling in a direction that has no more images,
      // then "bounce" the dragging, acheived by making it slow.
      diffX = bounceCalculationFn(diffX);

      // Move each image the distance the user has dragged.
      $.each([-imageDist, 0, imageDist], function(idx, val) {
        displayImages.eq(idx).css(transformCss(diffX + val));
      });
    };

    imagesContainer.on('mousemove.imggal', function(e) {
      swiping(e, false);
    });
    imagesContainer.on('touchmove.imggal', function(e) {
      swiping(e.originalEvent, true);

      showNav(true);
    });

    /**
     * Stops moving the image, and decides whether to cycle to the next
     * or previous image.
     */
    var swipeEnd = function() {
      if (!touching) {
        return;
      }

      /**
       * Calculate whether the user swiped fast enough or far enough
       * to change the image.
       *
       * @param {number} diffTime Time in milliseconds between touchstart
       *     and touchend.
       * @param {number} diffPos Distance in pixels between the point
       *     touched at touchstart until the last point before touchend.
       * @return {boolean} True if the time and distance meet a sufficient
       *     threshold to change the image.
       */
      var changeImage = function(diffTime, diffPos) {
        if (diffTime < minTime) {
          return diffPos > minTarget;
        }
        if (diffTime > maxTime) {
          return diffPos > maxTarget;
        }
        var rise = maxTime - minTime;
        var run = maxTarget - minTarget;
        return diffPos > minTarget + rise / run;
      };

      // Allow touch and keyboard events.
      preventInput = false;
      touching = false;

      resetImagePositions(displayImages);
      displayImages.removeClass(DRAGGED_STYLE);

      var diffTime = new Date().getTime() - startTouchTime;
      var diffPos = newX - startX;

      if (changeImage(diffTime, Math.abs(diffPos))) {
        var userSwipedLeft = diffPos < 0;
        !userSwipedLeft ? onPrev() : onNext();
      }
    };

    // Add swipe end handlers for mouse and touch.
    $.each(["mouseup.imggal", "touchend.imggal"],
        function(_, eventName) {
      imagesContainer.on(eventName, swipeEnd);
    });

    glass.on("mouseout.imggal", swipeEnd);
  };

  /**
   * IE10 appears to have a bug related to `position: relative`, z-index, and images.
   * In certain permutations, img elements are stacked in front of elements whose
   * parents are relatively positioned, regardless of z-index. Note that if you try
   * to inspect the problem elements in IE10 using the F12 tools, the stacking
   * order rectifies itself.
   *
   * Using `position: static` or `display: inline` seems to resolve this issue.
   */
  var browserFix_ie10Container = function() {
    if (common.isIE10) {
      imageGalleryContainer.css("display", "inline");
    }
  };

  /**
   * Center the image with javascript if IE7.
   *
   * @param {$Element} currentImage The element to center.
   */
  var browserFix_positionImage = function(currentImage) {
    if (common.isIE7) {
      var setImageMargins = function() {
        currentImage.off("load.imggalBrowserFix");
        common.centerElement(currentImage);
      };

      currentImage.on("load.imggalBrowserFix", setImageMargins);
      if (currentImage.prop("complete")) {
        // If image is loaded already, `onload` may not be fired.
        // Wait a bit for IE to set width/height.
        setTimeout(setImageMargins, 50);
      }
    }
  };

  /**
   * Cancels the HTML5 fullscreen mode, depending on the browser prefix.
   */
  var cancelFullScreen = function() {
    document[cancelFullScreenStr]();
  };

  /**
   * Helper method to generate CSS to translate the image in the x-axis.
   *
   * @param {number} x The x value for the translation.
   * @return {Object} The generated CSS including vendor prefixes.
   */
  var transformCss = function(x) {
    var value = x === undefined ? "" : "translate3d(" + x + "px, 0, 0)";
    return {
      "-webkit-transform": value,
      "-moz-transform": value,
      "transform": value
    };
  };

  /**
   * Checks if there is a next image that the user can navigate to.
   *
   * @return {boolean} True if not currently viewing the last image.
   */
  var hasNext = function() {
    return currentImageIdx < totalImages - 1;
  };

  /**
   * Checks if there is a previous image that the user can navigate to.
   *
   * @return {boolean} True if not currently viewing the first image.
   */
  var hasPrev = function() {
    return currentImageIdx > 0;
  };

  /**
   * Hides the bottom navigation bar.
   */
  var hideNav = function() {
    allNavs.addClass(NAV_HIDDEN_STYLE);
  };

  /**
   * From an array of images, load some head images into the display elements
   * and setup the image queue.
   *
   * @param {Array} imageArray An array of image URLs.
   */
  var initializeImages = function(imageArray) {
    images = imageArray;
    totalImages = images.length;
    currentImageIdx = opts.initImage;

    // Setup display image elements.
    loadAllViewableImages();

    // Update back and previous button on nav bar.
    hasNext() ? nextIcon.removeClass(GRAYED_OUT_STYLE) :
                nextIcon.addClass(GRAYED_OUT_STYLE);

    hasPrev() ? prevIcon.removeClass(GRAYED_OUT_STYLE) :
                prevIcon.addClass(GRAYED_OUT_STYLE);

    // Setup image queue.
    var firstQueuedIdx = currentImageIdx + 2;
    var endQueuedIdx = firstQueuedIdx + imageQueueSize;
    var imagesToQueue = images.slice(firstQueuedIdx, endQueuedIdx);

    imageQueue.each(function(idx, queueElem) {
      var src = imagesToQueue[idx];
      if (src === undefined) {
        // Queue space remains, but no more images.
        return false;
      }
      queueElem.src = src;
    });
    lastQueuedIdx = endQueuedIdx - 1;
  };

  /**
   * Add image gallery elements to the DOM and cache them.
   */
  var injectHtml = function() {
    if (imageGalleryContainer) {
      // HTML and elements are already cached.
      $(document.body).append(imageGalleryContainer);
      return;
    }

    $(document.body).append(imageGalleryHtml);

    // Add image queue with the provided number of elements.
    var queueElemArr = [];
    imageQueueSize = opts.prefetchSize;
    for (var i = 0; i < imageQueueSize; i++) {
      queueElemArr.push("<img src=''>");
    }
    var imageQueueContainer = $("#imggal-queue");
    imageQueueContainer.html(queueElemArr.join(""));
    imageQueue = imageQueueContainer.children();

    // Cache elements.
    allNavs = $("#imggal-nav, #imggal-nav-glass, #imggal-top");
    closeFullScreenIcon = $(".close-full-screen-icon");
    newTabIcon = $(".new-tab-icon");
    closeIcon = $(".close-icon");
    fullScreenIcon = $(".full-screen-icon");
    downloadIcon = $(".download-icon");
    glass = $('#imggal-glass');
    imageGalleryContainer = $("#imggal-container");
    browserFix_ie10Container();

    imagesContainer = $("#imggal-images");
    navBar = $("#imggal-nav");
    nextIcon = $(".next-icon");
    notNavBar = $("#imggal-images, #imggal-glass");
    onDeckContainer = $("#imggal-ondeck");
    prevIcon = $(".prev-icon");

    addNavBarHandlers();
    addSwipeHandlers();
  };

  /**
   * Checks if HTML5 fullscreen mode is enabled.
   *
   * @return {boolean} True if fullscreen mode is currently enabled.
   */
  var isFullScreen = function() {
    return document[isFullScreenStr];
  };

  /**
   * Checks whether the browser supports the CSS3 transform style. Note
   * that we currently only check for FF and webkit support.
   *
   * @return {boolean} True if the browser is capable of `transform`.
   */
  var isCss3TransformSupported = function() {
    // If not supported, try something.
    var $testElem = $("<div />");
    $(document.body).append($testElem);
    var testElem = $testElem.get(0);

    var transforms = {
      "webkitTransform": "-webkit-transform",
      "MozTransform": "-moz-transform",
      "transform": "transform"
    };

    var supportsTranslate3d = false;
    $.each(transforms, function(key, value) {
      if (testElem.style[key] !== undefined) {
        testElem.style[key] = "translate3d(1px, 1px, 1px)";
        var computedStyle = window.getComputedStyle(testElem).
            getPropertyValue(value);

        if (computedStyle && computedStyle.length && computedStyle !== "none") {
          supportsTranslate3d = true;
          return false;
        }
      }
    });

    $testElem.remove();

    return supportsTranslate3d;
  };

  /**
   * Load the correct images into the display elements, and their
   * associated "onDeck" containers for background loading.
   */
  var loadAllViewableImages = function() {
    var imageIdxOffset = currentImageIdx - 1;
    var onDeckImages = onDeckContainer.children();

    // For each image to display, setup ondeck and display elements.
    imagesContainer.children().each(function(idx) {
      var imageElem = $(this);
      var onDeckElem = onDeckImages.eq(idx);
      loadSingleImage(imageElem, onDeckElem, idx + imageIdxOffset);
    });

    setImageStyles();
  };

  /**
   * Load the specified image in the provided image elements.
   *
   * @param {$Element} imageElem The display element for this image.
   *     Initially set to the loading animation image.
   * @param {$Element} onDeckElem The background loading element for this image.
   * @param {number} idx The index of the image in the image array.
   */
  var loadSingleImage = function(imageElem, onDeckElem, idx) {
    var imageOutOfBounds = idx < 0 || idx >= totalImages;
    if (imageOutOfBounds) {
      imageElem.addClass(HIDDEN_STYLE);
      return;
    }

    imageElem.removeClass(HIDDEN_STYLE);

    // Show loading image by default.
    showImage(imageElem, LOADING_GIF);

    // Load image in background; after loaded, move to display container.
    var src = images[idx];
    onDeckElem.off("load.imggal");
    onDeckElem.on("load.imggal", function() {
      showImage(imageElem, src);
    });

    onDeckElem.attr("src", src);
    if (onDeckElem.prop("complete")) {
      // Image was cached - display immediately.
      onDeckElem.off("load.imggal");
      showImage(imageElem, src);
    }
  };

  /**
   * Enqueues an unloaded image if queue space exists.
   */
  var manageQueue = function() {
    if (lastQueuedIdx < totalImages - 1 &&
        lastQueuedIdx - currentImageIdx < imageQueueSize) {
      // Queue image - unloaded image exists, and queue is not full.
      imageQueue.get(0).src = images[++lastQueuedIdx];
    }
  };

  /**
   * Remove the image gallery from the DOM, but cache it for reopening.
   */
  var onClose = function() {
    imageGalleryContainer.detach();
    setupKeyHandlers(true);
    safelyInvokeCallback(closeCallback);

    toggleModal(false);
  };

  /**
   * Switch from fullscreen mode to normal gallery view, updating the nav
   * bar and styles.
   */
  var onCloseFullScreen = function() {
    allNavs.removeClass(NAV_FULL_STYLE);
    safelyInvokeCallback(closeFullScreenCallback);
  };

  /**
   * Switch to fullscreen mode, updating the nav bar and styles.
   */
  var onFullScreen = function() {
    allNavs.addClass(NAV_FULL_STYLE);
    safelyInvokeCallback(fullScreenCallback);
  };

  /**
   * Navigates to the next image, if it exists.
   */
  var onNext = function() {
    if (!preventInput && hasNext()) {
      ++currentImageIdx;

      switchImages(true);

      prevIcon.removeClass(GRAYED_OUT_STYLE);
      if (!hasNext()) {
        nextIcon.addClass(GRAYED_OUT_STYLE);
        showNav(true);
      }
    } else {
      showNav(true);
    }
    safelyInvokeCallback(nextCallback);
  };

  /**
   * Navigates to the previous image, if it exists.
   */
  var onPrev = function() {
    if (!preventInput && hasPrev()) {
      --currentImageIdx;

      switchImages(false);

      nextIcon.removeClass(GRAYED_OUT_STYLE);
      if (!hasPrev()) {
        prevIcon.addClass(GRAYED_OUT_STYLE);
        showNav(true);
      }
    } else {
      showNav(true);
    }
    safelyInvokeCallback(prevCallback);
  };

  /**
   * Sets a flag to prevent image transition and swiping - if
   * swipe transitions are enabled - and sets a timer to reenable.
   */
  var preventInputDuringTransition = function() {
    if (!opts.swipe) {
      // No transition is occurring.
      return;
    }

    preventInput = true;
    setTimeout(function() {
      preventInput = false;
    }, SWIPE_TRANSITION_TIME);
  };

  /**
   * Open HTML5 fullscreen mode.
   */
  var requestFullScreen = function() {
    imageGalleryContainer.get(0)[requestFullScreenStr]();
  };

  /**
   * Cycles the image display elements to facilitate image swiping
   * and prefetching.
   *
   * @param {boolean} next Indicates the direction of navigation.
   */
  var rotateDisplayElements = function(next) {
    var getOldElementFnStr = next ? "first" : "last";
    var appendElementFnStr = next ? "append" : "prepend";

    var imageElem = imagesContainer.children()[getOldElementFnStr]();
    var onDeckElem = onDeckContainer.children()[getOldElementFnStr]();
    imagesContainer[appendElementFnStr](imageElem);
    onDeckContainer[appendElementFnStr](onDeckElem);

    var imageIdx = currentImageIdx + (next ? 1 : -1);
    loadSingleImage(imageElem, onDeckElem, imageIdx);
  };

  /**
   * Calls the provided function, first verifying that it is a function.
   *
   * @param {Function} callback The function to call.
   */
  var safelyInvokeCallback = function(callback) {
    if (typeof callback === "function") {
      callback();
    }
  };

  /**
   * Sets a callback for when HTML5 fullscreen mode is enabled or disabled.
   *
   * @param {Function} callback The function call on change.
   */
  var setOnfullscreenchange = function(callback) {
    document[onfullscreenchangeStr] = callback;
  };

  /**
   * Add or remove key handlers, bound to the document, to navigate
   * images or close the image galley.
   *
   * @param {boolean} remove If true, the key handler will be removed.
   */
  var setupKeyHandlers = function(remove) {
    $document = $(document);
    $document.off("keydown.imggal");
    if (remove) {
      // Key handler removed only; no new key handler will be added.
      return;
    }

    /**
     * Callback function for key events for image navigation or for closing
     * the image gallery.
     *
     * @param {event} e The key event to get the keycode from.
     */
    var keyBindingCallback = function(e) {
      switch (e.which) {
        case KEY_ESCAPE:
          onClose();
          break;
        case KEY_LEFT:
        case KEY_UP:
        case KEY_H:
        case KEY_K:
        case KEY_NUMPAD_4:
        case KEY_NUMPAD_8:
        case KEY_PAGEUP:
          onPrev();
          break;
        case KEY_RIGHT:
        case KEY_DOWN:
        case KEY_L:
        case KEY_J:
        case KEY_NUMPAD_6:
        case KEY_NUMPAD_2:
        case KEY_PAGEDOWN:
        case KEY_ENTER:
          onNext();
          break;
        default:
          // Ignore
          break;
      }
    };

    // Add key handler.
    $document.on("keydown.imggal", keyBindingCallback);
  };

  /**
   * Sets the proper position styles for all display elements, depending
   * on their order.
   */
  var setImageStyles = function() {
    var displayImages = imagesContainer.children();
    $.each([-imageDist, 0, imageDist], function(idx, val) {
      val ? displayImages.eq(idx).addClass(OFF_SCREEN_STYLE) :
            displayImages.eq(idx).removeClass(OFF_SCREEN_STYLE);

      // Position images for swipe transitions.
      if (opts.swipe) {
        displayImages.eq(idx).css(transformCss(val));
      }
    });
  };

  /**
   * Display the image in the provided display element.
   *
   * @param {$Element} imageElem The display element to hold the image.
   * @param {string} src The image URL.
   */
  var showImage = function(imageElem, src) {
    browserFix_positionImage(imageElem);
    imageElem.attr("src", src);
  };

  /**
   * Display the nav bar, optionally setting a timeout to remove it.
   */
  var showNav = function(setHideTimeout) {
    window.clearTimeout(mousemoveTimeoutId);
    allNavs.removeClass(NAV_HIDDEN_STYLE);

    if (setHideTimeout) {
      mousemoveTimeoutId = window.setTimeout(hideNav, NAV_FADEOUT_TIME);
    }
  };

  /**
   * Detects support for HTML5 fullscreen mode, setting the property
   * and function names with vendor-specific prefixes if supported.
   *
   * @return {boolean} True if this browser supports fullscreen mode.
   */
  var supportsFullScreen = function() {
    if (document.webkitCancelFullScreen) {
      onfullscreenchangeStr = "onwebkitfullscreenchange";
      cancelFullScreenStr = "webkitCancelFullScreen";
      requestFullScreenStr = "webkitRequestFullScreen";
      isFullScreenStr = "webkitIsFullScreen";
      return true;
    }
    if (document.mozCancelFullScreen) {
      onfullscreenchangeStr = "onmozfullscreenchange";
      cancelFullScreenStr = "mozCancelFullScreen";
      requestFullScreenStr = "mozRequestFullScreen";
      isFullScreenStr = "mozFullScreen";
      return true;
    }
    return false;
  };

  /**
   * Cycle the displayed image to next or previous image, updating
   * styles and the image queue.
   *
   * @param {boolean} next True if cycling to the next image.
   */
  var switchImages = function(next) {
    preventInputDuringTransition();
    rotateDisplayElements(next);
    setImageStyles();
    manageQueue();
  };

  /**
   * Prevent scrolling of the background, making the image gallery
   * modal.
   *
   * @param {boolean} modal If true, prevent scrolling; if false, enables it.
   */
  var toggleModal = function(modal) {
    modal ? $("html").addClass(MODAL_STYLE)
          : $("html").removeClass(MODAL_STYLE);
  };

  templates.addTemplate("imageGallery", imageGalleryTemplate);

  i18n.done(function(intl) {
    var context = {
      closeIcon: intl.L("ImageGallery.button.close"),
      closeFullScreenIcon: intl.L("ImageGallery.button.closeFullScreen"),
      newTabIcon: intl.L("ImageGallery.button.open"),
      fullScreenIcon: intl.L("ImageGallery.button.fullScreen"),
      downloadIcon: intl.L("ImageGallery.button.download"),
      nextIcon: intl.L("ImageGallery.button.next"),
      prevIcon: intl.L("ImageGallery.button.prev")
    };
    imageGalleryHtml = templates.imageGallery(context, true);

    if (deferredShow) {
      // Tried to load gallery before i18n; reload gallery.
      me.show(deferredShow.imageArray, deferredShow.options);
      deferredShow = null;
    }
  });

  var me = {
    /*
     * Hide the image gallery lightbox, and remove mouse and keyboard
     * handlers. Usually called from inside the lightbox, but this
     * method allows the parent's javascript to effect the same.
     */
    hide : onClose,

    setCloseCallback : function(callback) {
      closeCallback = callback;
    },

    setCloseFullScreenCallback : function(callback) {
      closeFullScreenCallback = callback;
    },

    setFullScreenCallback : function(callback) {
      fullScreenCallback = callback;
    },

    setNextCallback : function(callback) {
      nextCallback = callback;
    },

    setPrevCallback : function(callback) {
      prevCallback = callback;
    },

    allowInput : function(value) {
      preventInput = !value;
    },

    setCurrentImage: function(img) {
      currentImageIdx = images.indexOf(img.src);
      showImage(img);
    },

    /*
     * Shows the lightbox. If an imageArray (of URIs) is specified,
     * these images are loaded into the lightbox. If not, then the last
     * images are displayed. Takes in options.
     */
    show : function(imageArray, options) {
      if (!imageGalleryHtml) {
        deferredShow = {
          imageArray: imageArray,
          options: options
        };
        return;
      }
      options = (options && typeof options == "object") ? options : {};
      opts = $.extend({}, DEFAULTS, options);

      if (!isCss3TransformSupported()) {
        opts.swipe = false;
      }

      // Init image can be an image url or its position
      if (typeof opts.initImage == "string") {
        opts.initImage = imageArray.indexOf(opts.initImage);
      }
      injectHtml();
      initializeImages(imageArray);
      imageGalleryContainer.removeClass(HIDDEN_STYLE);
      showNav();

      toggleModal(true);
      setupKeyHandlers();
    }
  };

  return me;
});
